#!/usr/bin/env python3

import argparse as arse
import sqlite3 as sqli
from traceback import format_exc
from tabulate import tabulate
from datetime import datetime, date
from colorama import Back, Fore, init  # Colored output
from sys import exc_info
from pathlib import Path
import os
import re

# OS specific connection string with pathlib
if os.name == "nt":  # Windows
    db_dir = Path(Path.home(), "AppData", "Local")
else:  # Linux
    db_dir = Path(Path.home(), ".config")

# Construct the full path to the SQLite database file
DB_FILE = Path(db_dir, "exam.db")

# Initialize colorama
init(autoreset=True)


# ==============================
#  COUNTDOWN UTILITY
# ==============================
def countdown(later_date: str) -> int:
    """
    Accepts a date string and counts the number of days until the specified
    date.
    
    :param later_date: Specified date in string form, formatted as '%Y-%m-%d'.
    :type later_date: str
    :return: The integer number of days until the given date.
    :rtype: int
    """
    return (
        datetime.strptime(later_date, "%Y-%m-%d") - 
        datetime.strptime(date.today().isoformat(), "%Y-%m-%d")
    ).days


# ==============================
#  DATE REGEX UTILITY
# ==============================
def date_time_regex_util(date: str | None = None,
              time: str | None = None) -> str:
    """
    Parses a string, searches for a date (formatted as '%Y-%m-%d') or a time
    (formatted as '%H:%M'), and returns the grouped results. Specifies the
    format of the date and time in question, in case of typos or bad data
    (because SQLite3 stores dates as strings).
    
    :param date: The string containing the purported date.
    :type date: str | None
    :param time: The string containing the purported time.
    :type time: str | None
    :return: The grouped result of the regex search.
    :rtype: str
    """
    dateRegex = re.compile(r'\d{4}-\d{2}-\d{2}')
    timeRegex = re.compile(r'(\d)?\d:\d{2}')

    if date:
        dateR = dateRegex.search(date)

        return dateR.group()
    
    if time:
        timeR = timeRegex.search(time)

        return timeR.group()



# ==============================
#  COLOURING UTILITY
# ==============================
def colour_util(days: int,
               colours: tuple[
                   str,
                   str,
                   str
                ]) -> str:
    """
    Accepts an int and a tuple of strings, and returns one of the strings
    based on the value of the int. Intended to be used for dynamic row
    colouring with colorama.
    
    :param days: The number of days until the exam to be coloured.
    :type days: int
    :param colours: The tuple of colours to use, containing three potential
    colours. One is selected based on the exam's position in the result set.
    :type colours: tuple[str, str, str]
    :return: The colour that was selected based on the number of days until
    the exam starts.
    :rtype: str
    """
    if days in range(8, 15):
        return colours[0]
    elif days <= 7:
        return colours[1]
    else:
        return colours[2]


# ==============================
#  DATABASE INITIALIZATION
# ==============================
def init_db() -> None:
    """
    Initializes SQLite3 database in user's home directory.
    """

    with sqli.connect(DB_FILE) as sqliconn:
        sqlicur = sqliconn.cursor()

        sqlicur.executescript("""
create table if not exists Semester (
    semester_id integer primary key autoincrement,
    year integer not null,
    term text not null,
    unique(year, term)
);

create table if not exists Course (
    course_id integer primary key autoincrement,
    code text not null,
    name text,
    semester_id integer not null,
    foreign key (semester_id) references Semester(semester_id)
);

create table if not exists Exam (
    exam_id integer primary key autoincrement,
    course_id integer not null,
    type text not null check (type in ('Midterm', 'Final')),
    number integer,
    date text not null,
    start text,
    end text,
    location text,
    foreign key (course_id) references Course(course_id)
);

create view if not exists Overview as
select
    s.year as year,
    s.term as term,
    c.code as code,
    c.name as name,
    e.type as type,
    e.number as number,
    e.date as date,
    e.start as start,
    e.end as end,
    e.location as location
from Exam e
join Course c on e.course_id = c.course_id
join Semester s on c.semester_id = s.semester_id;
""")
        
        sqliconn.commit()


# ==============================
#  INSERT EXAMS
# ==============================
def insert(year: int, term: str, code: str, name: str,
           type: str, date_str: str,
           start_str: str | None = None,
           end_str: str | None = None,
           number: int | None = None,
           location: str | None = None) -> None:
    """
    Inserts items into the database.
    
    :param year: The year of the semester in which the exam occurs.
    :type year: int
    :param term: The semester in which the exam occurs. Either 'Fall' or
    'Winter'.
    :type term: str
    :param code: The course code pertaining to the exam.
    :type code: str
    :param name: The name of the course the exam is for.
    :type name: str
    :param type: The type of exam. Either a 'Midterm' or a 'Final'.
    :type type: str
    :param date_str: The date of the exam, formatted as '%Y-%m-%d'.
    :type date_str: str
    :param start_str: The start time of the exam, formatted as '%H:%M'.
    :type start_str: str | None
    :param end_str: The end time of the exam, formatted as '%H:%M'.
    :type end_str: str | None
    :param number: The sequential number of the exam. For cases in which
    there is more than one midterm, for example.
    :type number: int | None
    :param location: The building/room where the exam will be held. Can also
    store brief notes about the nature of the exam (data type is 'text').
    :type location: str | None
    """

    # Insert a new exam record with validation and safety checks.
    try:
        datetime.strptime(date_str, "%Y-%m-%d")

        if start_str:
            datetime.strptime(start_str, "%H:%M")
        if end_str:
            datetime.strptime(end_str, "%H:%M")

    except ValueError as e:
        print(f"âŒ {e}")
        return
    
    if type.title() not in ("Midterm", "Final"):
        print("âŒ Exam type must be 'Midterm' or 'Final'.")
        return

    with sqli.connect(DB_FILE) as sqliconn:
        sqlicur = sqliconn.cursor()

        try:
            # Ensure semester exists
            sqlicur.execute(
                "insert or ignore into Semester (year, term) values (?, ?)",
                (year, term)
            )

            sem_id = sqlicur.execute(
                "select semester_id from Semester where year=? and term=?",
                (year, term)
            ).fetchone()[0]

            # Ensure course exists (reuse if it already does)
            sqlicur.execute(
                "select course_id from Course where code=? and semester_id=?",
                (code, sem_id)
            )
            existing = sqlicur.fetchone()
            if existing:
                course_id = existing[0]
            else:
                sqlicur.execute(
                    "insert into Course (code, name, semester_id) values (?, ?, ?)",
                    (code, name, sem_id)
                )
                course_id = sqlicur.lastrowid

            # Insert exam
            sqlicur.execute("""
insert into Exam (course_id, type, number, date, start, end, location)
values (?, ?, ?, ?, ?, ?, ?)
""", (course_id, type, number, date_str, start_str, end_str, location))
            
            sqliconn.commit()
            print(f"âœ… Exam added: {code} ({type}) on {date_str}")
        
        except sqli.IntegrityError as e:
            print(f"âŒ Database integrity error: {e}")
        except Exception as e:
            print(f"âŒ Unexpected error: {e}")


# ==============================
#  SHOW EXAMS
# ==============================
def fetch(code: str | None = None,
          year: int | None = None,
          term: str | None = None,
          type: str | None = None,
          upcomingOnly: bool = True) -> list:
    """
    Queries the database based on either course code, year, term, exam type,
    or no criteria. Filters either for upcoming exams only or all exams.
    Returns a list of row results.
    
    :param code: The course code pertaining to the exam.
    :type code: str | None
    :param year: The year of the semester in which the exam occurs.
    :type year: int | None
    :param term: The semester in which the exam occurs. Either 'Fall' or
    'Winter'.
    :type term: str | None
    :param type: The type of exam. Either a 'Midterm' or a 'Final'.
    :type type: str | None
    :param upcomingOnly: Filter for future exams only.
    :type upcomingOnly: bool
    :return: List of rows fetched.
    :rtype: list
    """

    # Fetch and display exams, optionally filtered by year and term.
    query = "select code, name, type, date, start, end, location from Overview"

    filters = []
    params = []

    if code is not None:
        filters.append("code = ?")
        params.append(code)
    if year is not None:
        filters.append("year = ?")
        params.append(year)
    if term is not None:
        filters.append("term = ?")
        params.append(term)
    if type is not None:
        filters.append("type = ?")
        params.append(type)
    
    if upcomingOnly and not year and not term and not type and not code:
        filters.append("(date > ? or (date = ? and end >= ?))")
        params.extend([date.today().isoformat(),
                       date.today().isoformat(),
                       datetime.now().strftime("%H:%M")])

    if filters:
        query += " where " + " and ".join(filters)

    query += " order by date asc, start asc, end asc;"

    # print(query, params)  # DEBUG

    with sqli.connect(DB_FILE) as conn:
        cur = conn.cursor()
        cur.execute(query, params)
        rows = cur.fetchall()

        # print(rows)  # DEBUG

        return rows


# ==============================
#  PRINT
# ==============================
def printout(data: list[list] | list,
             code: str | None = None,
             containsCurrent: bool = False) -> bool:
    """
    Accepts a list, applies formatting row-by-row, and prints to the
    screen.
    
    :param data: The list to be parsed.
    :type data: list[list] | list
    :param code: The course code, for output filtering.
    :type code: str | None
    :param containsCurrent: Does the list of data contain an exam that happens
    either now or later?
    :type containsCurrent: bool
    :return: True if successful, False otherwise.
    :rtype: bool
    """
    if not data:
        print(f"âš ï¸ No exams found for that selection."
              f"  You may have finished all of your upcoming exams!")
        return True
    
    colours = [
        (Fore.LIGHTYELLOW_EX, Fore.LIGHTRED_EX, Fore.LIGHTGREEN_EX),
        (Fore.YELLOW, Fore.LIGHTYELLOW_EX, Fore.RESET)
    ]
    
    countedDaysTop = 0  # Countdown to next exam
    colour1, colour2 = Fore.RESET, None  # Output colours
    countColour = None
    top = None  # Topmost entry in result set

    """
    Output data initally matches all input data, unless a code is
    specified by the user.
    """
    dataO = data[:] \
        if not code else [x for x in data if x[0] == code]

    # Header list formatting
    headers = [Back.BLUE +
               Fore.LIGHTWHITE_EX +
               x +
               Fore.RESET +
               Back.RESET
               for x in
               [
                   "Course",
                   "Name",
                   "Type",
                   "Date",
                   "Start",
                   "End",
                   "Location"
                ]]

    # Only highlight exams that are now or later
    for i in range(len(dataO)):
        if (dataO[i][3] > date.today().isoformat()
            or (
                dataO[i][3] == date.today().isoformat()
                and
                dataO[i][5] >= datetime.now().strftime("%H:%M")
            )):
            containsCurrent = True

            # Format the top row
            top = dataO[i]

            countedDaysTop = countdown(top[3])

            colour1 = colour_util(countedDaysTop, colours[0])
            
            # Format the second row, if exists
            if len(dataO) > 1:
                second = dataO[i + 1]

                countedDaysSecond = countdown(second[3])

                colour2 = colour_util(countedDaysSecond, colours[1])
            
                if countedDaysTop in range(15):
                    dataO[i + 1] = [colour2 + x + Fore.RESET for x in dataO[i + 1]]
            
            dataO[i] = [colour1 + x + Fore.RESET for x in dataO[i]]
            
            countColour = colour1

            break
        else:
            colour1 = Fore.GREEN

            top = data[0]

    # Print table
    print(tabulate(dataO, headers=headers, tablefmt="grid"))

    # Find date and time of topmost entry
    dateR = date_time_regex_util(date=top[3])
    timeR = date_time_regex_util(time=top[4])

    if dataO and containsCurrent:
        print(f"Days until {"next" if len(dataO) > 1 and not code else "this"} exam: {countColour}{countedDaysTop}")
        
        print(f"Study {colour1}{top[1]}{Fore.RESET} "
                f"before {Fore.LIGHTMAGENTA_EX}{datetime.strptime(dateR, "%Y-%m-%d").strftime("%b %d, %Y")}{Fore.RESET} "
                f"at {Fore.LIGHTCYAN_EX}{datetime.strptime(timeR, "%H:%M").strftime("%I:%M %p")}"
                f"{Fore.RESET}!")
    else:
        print(f"{Fore.LIGHTGREEN_EX}No exams to worry about here!")
    
    return True


# ==============================
#  DELETE EXAMS
# ==============================
def remove(code: str, year: int, term: str) -> None:
    """
    Deletes an exam from the database.
    
    :param code: The course code pertaining to the exam.
    :type code: str | None
    :param year: The year of the semester in which the exam occurs.
    :type year: int | None
    :param term: The semester in which the exam occurs. Either 'Fall' or
    'Winter'.
    :type term: str | None
    """

    # Delete all exams for a course in a given semester.
    with sqli.connect(DB_FILE) as conn:
        cur = conn.cursor()
        cur.execute("""
            delete from Exam
            where course_id in (
                select c.course_id
                from Course c
                join Semester s ON c.semester_id = s.semester_id
                where c.code=? AND s.year=? AND s.term=?
            );
        """, (code.upper(), year, term))
        count = cur.rowcount
        conn.commit()

        if count:
            print(f"ðŸ—‘ï¸  Deleted {count} exam(s) for {code.upper()} ({term} {year}).")
        else:
            print(f"âš ï¸  No exams found for {code.upper()} in {term} {year}.")


# ==============================
#  MAIN CLI INTERFACE
# ==============================
def main() -> int:
    """
    Entry point for the scheduler CLI.
    
    Parses command-line arguments, initializes the database,
    executes the requested command, and returns an exit code.
    
    :return: Exit code.
    :rtype: int
    """
    parser = arse.ArgumentParser(description="Exam Scheduler using SQLite3")
    subparsers = parser.add_subparsers(dest="command")
    parser.set_defaults(command="show")

    # INSERT
    insert_parser = subparsers.add_parser("insert", help="Insert a new exam record")
    insert_parser.add_argument("year", type=int)
    insert_parser.add_argument("term", help="Term (Fall, Winter, etc.)")
    insert_parser.add_argument("code", help="Course code (e.g. ECON101)")
    insert_parser.add_argument("name", help="Course name (quoted if spaced)")
    insert_parser.add_argument("type", help="Exam type (Midterm/Final)")
    insert_parser.add_argument("date", help="Exam date (YYYY-MM-DD)")
    insert_parser.add_argument("location", help="Exam location")

    insert_parser.add_argument("--start", nargs="?", help="Start time (HH:MM)")
    insert_parser.add_argument("--end", nargs="?", help="End time (HH:MM)")
    insert_parser.add_argument("--number", type=int, nargs="?", help="Midterm number")

    # SHOW
    show_parser = subparsers.add_parser("show", help="Show all exams")
    show_parser.add_argument("--code", type=str, nargs="?")
    show_parser.add_argument("--year", type=int, nargs="?")
    show_parser.add_argument("--term", nargs="?")
    show_parser.add_argument("--type", nargs="?")
    show_parser.add_argument("--all", action="store_true", help="Show all exams (including past ones)")

    # DELETE
    delete_parser = subparsers.add_parser("delete", help="Delete exams for a course")
    delete_parser.add_argument("year", type=int)
    delete_parser.add_argument("term")
    delete_parser.add_argument("code")

    args = parser.parse_args()

    init_db()

    # print(args)  # DEBUG

    if args.command == "insert":
        insert(
            args.year, args.term, args.code, args.name,
            args.type, args.date, args.start, args.end,
            args.number, args.location
        )
    elif args.command == "delete":
        remove(
            args.year,
            args.term,
            args.code
        )
    elif args.command == "show":
        if printout(
            data=fetch(
                year=getattr(args, "year", None),
                term=getattr(args, "term", None),
                type=getattr(args, "type", None),
                upcomingOnly=not getattr(args, "all", False)
            ),
            code=getattr(args, "code", None)
        ) is False:
            printout(
                data=fetch(
                    code=getattr(args, "code", None),
                    year=getattr(args, "year", None),
                    term=getattr(args, "term", None),
                    type=getattr(args, "type", None),
                    upcomingOnly=not getattr(args, "all", False)
                ),
                code=getattr(args, "code", None)
            )
    else:
        parser.print_help()
    
    return 0  # Return code
        

if __name__ == "__main__":
    try:
        # Exit with success
        raise SystemExit(main())

    except sqli.Error as e:
        exc_type, exc_obj, exc_tb = exc_info()

        print("SQLite connection error:", e)

        print(f"Error Type: {exc_type.__name__}")
        print(f"File Name: {exc_tb.tb_frame.f_code.co_filename}")
        print(f"Line Number: {exc_tb.tb_lineno}")

        print(format_exc())

        # Exit with fail
        raise SystemExit(1)

    except Exception as e:
        exc_type, exc_obj, exc_tb = exc_info()

        print("Error:", e)

        print(f"Error Type: {exc_type.__name__}")
        print(f"File Name: {exc_tb.tb_frame.f_code.co_filename}")
        print(f"Line Number: {exc_tb.tb_lineno}")

        print(format_exc())

        # Exit with fail
        raise SystemExit(1)
